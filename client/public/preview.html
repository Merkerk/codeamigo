<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body></body>
<script async defer type="text/babel">
  const MODULE_ROOT = "/node_modules";

  // hijack console log
  (function () {
    let oldlog = console.log;
    let oldinfo = console.info;
    let oldwarn = console.warn;
    console.log = function (message) {
      let msg = typeof message === 'string' ? message : JSON.stringify(message)
      window.parent.postMessage({ result: msg, from: 'preview', type: 'log' }, '*')
      oldlog.apply(console, arguments);
    };
    console.info = function (message) {
      let msg = typeof message === 'string' ? message : JSON.stringify(message)
      window.parent.postMessage({ result: msg, from: 'preview', type: 'info' }, '*')
      oldinfo.apply(console, arguments);
    };
    console.warn = function (message) {
      let msg = typeof message === 'string' ? message : JSON.stringify(message)
      window.parent.postMessage({ result: msg, from: 'preview', type: 'warn' }, '*')
      oldwarn.apply(console, arguments);
    };
  })();

  const transformCode = (code, path) => {
    return Babel.transform(code, {
      presets: ["es2015", "typescript", "react"],
      filename: path,
    });
  };

  // ⛔️⛔️⛔️⛔️⛔️
  // This code is important and should be tested
  // thoroughly when changed. It runs through all
  // possible files to get the next required path.
  // ⛔️⛔️⛔️⛔️⛔️
  const findBestMatch = (files, runPath) => {
    switch (true) {
      case !!files[runPath]: {
        return runPath;
      }
      case !!files[`${MODULE_ROOT}/${runPath}/index.js`]: {
        return `${MODULE_ROOT}/${runPath}/index.js`;
      }
      default:
        const fileKeys = Object.keys(files);
        const cleanRunPath = runPath.replace("./", "");

        const opt1 = fileKeys.find((file) => file.includes(`${cleanRunPath}.js`));
        const opt2 = fileKeys.find((file) => file.includes(cleanRunPath) && !file.includes('.json'));

        switch (true) {
          case opt1 !== undefined: {
            return opt1;
          }
          case opt2 !== undefined: {
            return opt2;
          }
        }

        console.error(`No file found for ${runPath}`);
    }
  };

  window.process = { env: { NODE_ENV: 'development' } }

  const exported = {}

  const runCode = (files, runPath) => {
    try {
      const path = findBestMatch(files, runPath);
      const code = files[path];
      const babelOutput = transformCode(code, path);

      const require = (path) => {
        return runCode(files, path);
      };

      const exports = {};
      const module = { exports };
      eval(babelOutput.code);
      
      if (!exported[runPath] && path.includes(MODULE_ROOT)) {
        exported[runPath] = module.exports
      }
      
      return exported[runPath] || module.exports;
    } catch (e) {
      console.log('⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️')
      console.log('Babel compliation error. Make sure that `findBestMatch` is working as intended!')
      console.log(`ERROR: ${e}`);
      console.log('⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️')
    }
  };

  window.addEventListener("message", ({ data }) => {
    if (data.from !== "editor") return;

    if (data.files['index.html']) {
      document.querySelector('body').innerHTML = data.files['index.html']
    }
    
    runCode(data.files, data.runPath);
  });
</script>

</html>